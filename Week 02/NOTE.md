## 优先队列与二叉堆

### 定义：
栈：先进后出

队列：先进先出

优先队列：优先级高先出


### 如何实现优先队列？

#### 首先我们尝试使用队列数组：

1、无序数组实现优先队列：

入队：放队尾 O(1)

出队：找最小值，挪动数组后半部分 O(N)



2、有序数组实现优先队列：

入队：插入合适位置，必要时挪动数组后半部分 O(N)

出队：删除数组末尾元素 O(1)



这么看队列数组逃不过O(N)操作，那么是否有更好的数据结构？

-----
#### 完全二叉树：除了最后一行，其他行都是满的二叉树，且最后一行所有叶子节点都是从左侧开始排列

完全二叉树的数组存储：

1、树根节点存储在a[1]

2、依次层序存储

3、k节点的父节点在k/2

4、k节点的两个子节点分别是 2*k 和 2*k+1


#### 堆只要增加一个性质：父元素存储的节点比子节点大

#### 堆上面我们定义两种操作：

1、上浮

不符合规则的点，与父节点交换

直到符合规则为止

复杂度logN


2、下沉

不符合规则的点，与子节点中大的交换

直到符合规则为止

复杂度logN


-------

### 这时我们使用堆实现优先队列

#### 入队：

待插入元素放在最后

上浮

复杂度 O(logN)


#### 出队：

最后一个节点换到根

下沉

复杂度 O(logN)


这么一顿操作后 复杂度由队列的O(N)降到使用堆的O(logN)


参考资料：
[优先队列与二叉堆](https://www.bilibili.com/video/BV13E411W7rU?from=search&seid=1389744232112622587)
[深入理解堆](https://blog.csdn.net/summerlq/article/details/82747940)
