## IEEE754标准 双精度(64位)浮点数

![img](https://img-blog.csdn.net/20170715123840325?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWJjZHUx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

|  名称   | 长度  | 比特位置  |
|  ----  | ----  | ----  |
| 符号位 Sign (S）  | 1bit | b63 |
| 指数部分Exponent（E）| 11bit | b62-b52 |
| 尾数部分Mantissa (M）| 52bit | b51-b0 |

双精度的指数部分（E）采用的偏置码为1023  
求值方法:
```
(-1)^S*(1.M)*2^(E-1023) 
```
注意：双精度数也可用%f格式输出，它的有效位一般为16位，给出小数6位。（这一点在计算金额的时候尤为重要，超过有效位的数字是无意义的，一般会出错。）  

>精度位总共是 53 bit，因为用科学计数法表示，所以首位固定的 1 就没有占用空间。即公式中 (M + 1) 里的 1。另外公式里的 1023 是 2^11 的一半。小于 1023 的用来表示小数，大于 1023 的用来表示整数。指数可以控制到 2^1024 - 1，而精度最大只达到 2^53 - 1，两者相比可以得出 JavaScript 实际可以精确表示的数字其实很少。

#### 举例分析：
double a=1024

(1024)10 = (10000000000)2 = 1*2^10;

以Double在内存中存储：

S=0;

E=(10+1023)10=10000001001;

M=1(省略);

### 精度损失
```javascript
0.1 + 0.2 != 0.3 // true
9999999999999999 == 10000000000000001 // true
```
#### 举例分析：
double a=0.8125  
针对小数部分 0.8125，采用乘 2 取整，顺序排列转为二进制
```
0.8125 * 2 = 1.625  |
0.625 * 2 = 1.25    | 顺序排列
0.25 * 2 = 0.5      |
0.5 * 2 = 1         ↓
```
得小数部分的二进制为 1101    

根据上面的知识将十进制小数 0.1 转为二进制：  
```
0.1 * 2 = 0.2
0.2 * 2 = 0.4 // 注意这里
0.4 * 2 = 0.8
0.8 * 2 = 1.6
0.6 * 2 = 1.2
0.2 * 2 = 0.4 // 注意这里，循环开始
0.4 * 2 = 0.8
0.8 * 2 = 1.6
0.6 * 2 = 1.2
...
```
可以发现有限十进制小数 0.1 却转化成了无限二进制小数 0.00011001100...，可以看到精度在转化过程中丢失了！   

能被转化为有限二进制小数的十进制小数的最后一位必然以 5 结尾(因为只有 0.5 * 2 才能变为整数)。所以十进制中一位小数 0.1 ~ 0.9 当中除了 0.5 之外的值在转化成二进制的过程中都丢失了精度。  

0.1以Double在内存中存储：  
S=0;  
E=(-4 + 1023)10=01111111011;  
M=1001100110011001100110011001100110011001100110011010;    

### JavaScript 的最大安全数是如何来的  
根据双精度浮点数的构成，精度位数是 53 bit。安全数的意思是在 -2^53 ~ 2^53 内的整数(不包括边界)与唯一的双精度浮点数互相对应。举个例子比较好理解：
``` 
Math.pow(2, 53) === Math.pow(2, 53) + 1 // true
```
`Math.pow(2, 53)` 竟然与` Math.pow(2, 53) + 1 `相等！这是因为` Math.pow(2, 53) + 1` 已经超过了尾数的精度限制(53 bit)，在这个例子中` Math.pow(2, 53)` 和 `Math.pow(2, 53) + 1 `对应了同一个双精度浮点数。所以` Math.pow(2, 53)` 就不是安全数了。

最大的安全数为 Math.pow(2, 53) - 1，即 9007199254740991。  


参考资料   
[IEEE754标准 单精度(32位)/双精度(64位)浮点数解码](https://blog.csdn.net/qq_42802219/article/details/96972346)  
[JavaScript 十进制小数转为二进制精度问题及解决方案](http://www.cainiaoxueyuan.com/gcs/6802.html)  
[JavaScript 浮点数陷阱及解法](https://github.com/camsong/blog/issues/9)  
[What Every Computer Scientist Should Know About Floating-Point Arithmetic](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html)  

---
